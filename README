device drivers:


the major and minor numbers usually identifies the driver associated with a specific device and the minor, the number of the device into that driver. Nowadays different drivers can shar the same major number although.
device numbers are represented by the dev_t type, which holds both, the major and minor numbers of a device. it's a 32-bit which uses 12 bits to store the major number and 20 for the minor. The code should never assumption about the internal organization of the numbers, but, use the following macros:
MAJOR(dev_t dev); retrieve the major number
MINOR(dev_t dev); retrieve the minor number
or
MKDEV(int major, int minor); to retrieve the device itself that belongs to the major and minor here

to allocate and free device numbers:

int register_chrdev_region(dev_t first, unsigned int count, char *name); /* statically allocates a device number. first is the beginning device number of the range, usually 0 */
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsignet int count, char *name); /* Dynamically allocates the major number. *dev will hold the first number of the allocated range, and firstminor should be the requested first minor number to use */
void unregister_chrdev_region(dev_t first, unsigned int count); /* free device numbers, usually called from the module's cleanup function*/

These functions allocate device numbers for the driver's use, but they do not tell the kernel anything about what you will actually do with those numbers. Before allow user-space programs to access one of these device numbers, the driver needs to connect them to its internal functions that implement the device's operation.

Most of the fundamental driver operations involve three important kernel data structures: file_operations, file and inode

Kernel uses a struct of type struct cdev to represent a char device internally, and before the kernel invoke any device operation, one or mor cdev structures should be allocated and initialized.
<linux/cdev.h> contains all necessary structures and functios to lead with cdev.
There are two ways of allocating and initializind these structures:
- Stand alloc at runtime, like:
	struct cdev *my_cdev = cdev_alloc;
	my_cdev->ops = &my_fops;
- Embed the cdev structure within a device specific structure, which, in that case, the already allocated cdev structure should be initialized with:
	void cdev_init(struct cdev *cdev, struct file_operations *fops);
The cdev structure also contains a .owner field that should be set to THIS_MODULE.

Once the cdev structure is set up, the final step is to tell the kernel about it, with a call to:
	int cdev_add(struct cdev *dev, dev_t num, unsigned int count);
where:  dev is the cdev structure,
	num, is the first device number to which this device responds, and
	count is the number of device numbers that should be associated with the device.

Important things to keep in mind about using cdev_add:
	-This call can fail. If it returns a negative error code, the device has not been added to the system
	-As soon as cdev_add returns (with success), the device is "live", and its operations can be called by the kernel. So, make sure to not call cdev_add until the driver is completely ready to handle operations on the device.

To remove a char device from the system:
	void cdev_del(struct cdev *dev);

NEVER access the cdev structure after passes it to cdev_del :)

scull represents each device with a structure of type struct scull_dev, defined as:

	struct scull_dev {
		struct scull_qset *data; /* pointer to first quantum set */
		int quantum;		 /* the current quantum size */
		int qset;		 /* the current array size */
		unsigned long size;	 /* amount of data stored here */
		unsigned int access_key; /* used by sculluid and scullpriv */
		struct semaphore sem;	 /* mutual exclusion semaphore */
		struct cdev cdev;	 /* Char device structure */
	}

The open method 

is provided for the driver to init and prepare itself for later operations, where, in most cases the open method should perform:
	- Check for device-specific errors (such as device-not-ready or similar hardware problems)
	- Initialize the device if it is being opened for the first time
	- Update the f_op pointer, if necessary
	- Allocate and fill any data structure to be put in filp->private_data

First thing is to identify which device is being opened.  /* int (*open)(struct inode *inode, struct file *filp); */
The inode argument of the open method contains this information into the inode->i_cdev, but the driver works with scull_dev structures itself.
so, it uses the container_of() macro to search for the scull_dev structure that contains the specific cdev pointer:

container_of(ptr, type, member)

this macro will return the pointer to the structure of struct 'type', which contains into the 'member' field, a pointer to ptr, for example:

struct foo bar = { a = 5};

int *b = &a;

int c = container_of(b, struct foo, a);

/* int c will contain a pointer to a */

Another way to identify the device being opened, is looking at the minor number stored in the inode structure, that must be used if the device was registered with register_chrdev.
inode->iminor number is used to obtain the minor number, but, be sure that it corresponds to the device the driver is prepared to handle

The release method

The release method act as the reverse of open method. Is possible to find method implementation called device_close instead of device_release, and the method should perform the following tasks:
	- Deallocate anything that open allocated in filp->private_data
	- Shutdown the device on last close

What happens when a device file is closed more times than it is opened ? After all, the dup and fork system calls create copies of the open files without calling open; each of those copies is then closed at program termination.
Example: most program don't open their stdin device, but all of them end up closing it. How does the driver know when an open device file has really been closed ?

Not every close system call causes the release method to be invoked, only the calls that actually release the device data structure (so, the name's method). The file keeps a counter of how many times a file structure is being used. 
Neither fork nor dup creates a new file structure (only open does that), but they increment the counter in the existing structure, and the close system call just call the release method when the counter for the file structure drops to 0,
which happens when the structure is destroyed.

The flush flush methos is called every time an application calls close, but, very few derivers implements flush, because usually there is nothing to perform at close time, unless release is involved.

The previous discussion applies even when the application terminates without explicitly closing its open files, the kernel automatically closes any file at process exit time ( by internally using the close syscall).
