device drivers:


the major and minor numbers usually identifies the driver associated with a specific device and the minor, the number of the device into that driver. Nowadays different drivers can shar the same major number although.
device numbers are represented by the dev_t type, which holds both, the major and minor numbers of a device. it's a 32-bit which uses 12 bits to store the major number and 20 for the minor. The code should never assumption about the internal organization of the numbers, but, use the following macros:
MAJOR(dev_t dev); retrieve the major number
MINOR(dev_t dev); retrieve the minor number
or
MKDEV(int major, int minor); to retrieve the device itself that belongs to the major and minor here

to allocate and free device numbers:

int register_chrdev_region(dev_t first, unsigned int count, char *name); /* statically allocates a device number. first is the beginning device number of the range, usually 0 */
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsignet int count, char *name); /* Dynamically allocates the major number. *dev will hold the first number of the allocated range, and firstminor should be the requested first minor number to use */
void unregister_chrdev_region(dev_t first, unsigned int count); /* free device numbers, usually called from the module's cleanup function*/

These functions allocate device numbers for the driver's use, but they do not tell the kernel anything about what you will actually do with those numbers. Before allow user-space programs to access one of these device numbers, the driver needs to connect them to its internal functions that implement the device's operation.

Most of the fundamental driver operations involve three important kernel data structures: file_operations, file and inode

Kernel uses a struct of type struct cdev to represent a char device internally, and before the kernel invoke any device operation, one or mor cdev structures should be allocated and initialized.
<linux/cdev.h> contains all necessary structures and functios to lead with cdev.
There are two ways of allocating and initializind these structures:
- Stand alloc at runtime, like:
	struct cdev *my_cdev = cdev_alloc;
	my_cdev->ops = &my_fops;
- Embed the cdev structure within a device specific structure, which, in that case, the already allocated cdev structure should be initialized with:
	void cdev_init(struct cdev *cdev, struct file_operations *fops);
The cdev structure also contains a .owner field that should be set to THIS_MODULE.

Once the cdev structure is set up, the final step is to tell the kernel about it, with a call to:
	int cdev_add(struct cdev *dev, dev_t num, unsigned int count);
where:  dev is the cdev structure,
	num, is the first device number to which this device responds, and
	count is the number of device numbers that should be associated with the device.

Important things to keep in mind about using cdev_add:
	-This call can fail. If it returns a negative error code, the device has not been added to the system
	-As soon as cdev_add returns (with success), the device is "live", and its operations can be called by the kernel. So, make sure to not call cdev_add until the driver is completely ready to handle operations on the device.

To remove a char device from the system:
	void cdev_del(struct cdev *dev);

NEVER access the cdev structure after passes it to cdev_del :)

scull represents each device with a structure of type struct scull_dev, defined as:

	struct scull_dev {
		struct scull_qset *data; /* pointer to first quantum set */
		int quantum;		 /* the current quantum size */
		int qset;		 /* the current array size */
		unsigned long size;	 /* amount of data stored here */
		unsigned int access_key; /* used by sculluid and scullpriv */
		struct semaphore sem;	 /* mutual exclusion semaphore */
		struct cdev cdev;	 /* Char device structure */
	}

The open method is provided for the driver to init and prepare itself for later operations, where, in most cases the open method should perform:
	- Check for device-specific errors (such as device-not-ready or similar hardware problems)
	- Initialize the device if it is being opened for the first time
	- Update the f_op pointer, if necessary
	- Allocate and fill any data structure to be put in filp->private_data

First thing is to identify which device is being opened.  /* int (*open)(struct inode *inode, struct file *filp); */
The inode argument of the open method contains this information into the inode->i_cdev, but the driver works with scull_dev structures itself.
so, it uses the container_of() macro to search for the scull_dev structure that contains the specific cdev pointer:

container_of(ptr, type, member)

this macro will return the pointer to the structure of struct 'type', which contains into the 'member' field, a pointer to ptr, for example:

struct foo bar = { a = 5};

int *b = &a;

int c = container_of(b, struct foo, a);

/* int c will contain a pointer to a */
















